h1. Extra Apache Camel methods for Scala

Despite the fact this project relies on "camel-scala":http://camel.apache.org/scala-dsl.html component from Apache Camel, it provides alternative way to write routes. Instead of using beta DSL from camel-scala, you use very limited choice of implicits (certainly you can always use more from "camel-scala").

Basically this project provides:

* few pimps for writing `RouteBuilder`s
* few Camel converters for Scala types and collections

h2. RouteHelper

@com.osinka.scala.camel.RouteBuilderHelper@ trait is provided to ease writing RouteBuilders. To start:

<pre><code>class MyRouteBuilder extends RouteBuilder with RouteBuilderHelper {
  override def configure {</code></pre>

h3. Rich objects

"camel-scala" provides a useful implicit conversion to enrich objects of `Exchange`. Consult the source code of "camel-scala" project in "Apache Camel sources":https://github.com/apache/camel since there is no javadoc/scaladoc published. Basically you can do the following and alike:

* @exchange.in = message@ instead of @exchange.getIn.setBody(message)@
* @val obj = exchange.in[Type]@ instead of @val obj = exchange.getIn.getBody(classOf[Type])@
* @val out: Any = exchange.out@ instead of @val out: Any = exchange.getOut.getBody@
* @val header = exchange.in("header")@ instead of @val header = exchange.getIn.getHeader("header")@

h3. Processors

Many processors / filters in routes operate on only one part of @Exchange@, e.g. on "in" only. You can express such processor/filters with short wrappers like:

* @process(in[Int] { 1+ } .toIn)@ will try to convert "in" message of the exchange to @Int@, increment by 1 and write it back to "in". The is the same as @process(in[Int] { 1+ })@
* Otherwise, you can process "out": @process(out[Int] {1+})@ will write the result into "in". To write it into "out": @process(out[Int] {1+} .toOut)@

Sometimes you just need a side-effect which does not depend on @Exchange@:

* @process{ cronJob.run }@

h3. Filters

Use the same DSL for filters:

* @filter(in[Int] {0==})@

h2. Converters

Few Camel type converters for Scala types:

* Scala @Symbol@ <=> @String@

Immutable collections conversions:

* Scala @Iterator@ <=> Java @Iterator@
* Scala @Iterator@ <=> Java @Enumeration@
* Scala @Iterable@ <=> Java @Iterable@
* Scala @Iterable@ <=> Java @Collection@
* Scala @Set@ => Java @Set@
* Scala @Map@ => Java @Map@
* Scala @Seq@ => Java @List@

Mutable collections conversions:

* Scala @Buffer@ <=> Java @List@
* Scala @Set@ <=> Java @Set@
* Scala @Map@ <=> Java @Dictionary@
* Scala @Map@ <=> Java @Map@
* Scala @ConcurrentMap@ <=> Java @ConcurrentMap@
* Scala @Seq@ => Java @List@

Option conversions:

* @Option@ => @Iterable@
* @Option@ => @Iterable@
* @Option@ => @List@
* @Option@ => Java @List@
* @Option@ => Java @Collection@
* @Option@ => Java @Iterator@
* @Option@ => Java @Iterable@
